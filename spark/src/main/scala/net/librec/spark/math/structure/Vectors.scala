/**
  * Copyright (C) 2016 LibRec
  * <p>
  * This file is part of LibRec.
  * LibRec is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  * <p>
  * LibRec is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  * GNU General Public License for more details.
  * <p>
  * You should have received a copy of the GNU General Public License
  * along with LibRec. If not, see <http://www.gnu.org/licenses/>.
  */
package net.librec.spark.math.structure

import net.librec.math.structure
import net.librec.math.structure.{VectorBasedSequentialSparseVector, Vector => CoreVector}


/**
  * Represents a numeric vector, whose index type is Int and value type is Double.
  *
  * @author WangYuFeng
  */
trait Vector extends Serializable {

  /**
    * Size of the vector.
    */
  def size: Int

  def values: Array[Double]

  /**
    * Converts the instance to a double array.
    */
  def toArray: Array[Double]

  /**
    * Convert this vector to the new mllib-local representation.
    */
  def asLocalVector: CoreVector

  /**
    * Transform each element by function ''f''.
    *
    * @param f
    */
  def foreachActive(f: (Int, Double) => Unit): Unit

}

class DenseVector(val values: Array[Double]) extends Vector {
  override def size: Int = values.length

  override def toArray: Array[Double] = values

  /**
    * Convert this vector to the new librec-local representation.
    */
  override def asLocalVector: structure.DenseVector = new net.librec.math.structure.VectorBasedDenseVector(values)

  /**
    * @see net.librec.spark.math.structure#foreachActive((Int, Double) => Unit)
    */
  override def foreachActive(f: (Int, Double) => Unit): Unit = {
    var i = 0
    val localValuesSize = values.length
    val localValues = values

    while (i < localValuesSize) {
      f(i, localValues(i))
      i += 1
    }
  }

}

class SparseVector(override val size: Int,val indices: Array[Int],val values: Array[Double]) extends Vector {

  override def toArray: Array[Double] = {
    println("size--",size,"--indices--",indices.mkString(","),"--value--",values.mkString(","))
    val data = new Array[Double](size)
    var i = 0
    val nnz = indices.length
    while (i < nnz) {
      data(indices(i)) = values(i)
      i += 1
    }
    data
  }

  /**
    * Convert this vector to the new librec-local representation.
    */
  override def asLocalVector: VectorBasedSequentialSparseVector = new VectorBasedSequentialSparseVector(size, indices, values)

  /**
    * @see net.librec.spark.math.structure#foreachActive((Int, Double) => Unit)
    */
  override def foreachActive(f: (Int, Double) => Unit): Unit = {
    var i = 0
    val localValuesSize = values.length
    val localIndices = indices
    val localValues = values

    while (i < localValuesSize) {
      f(localIndices(i), localValues(i))
      i += 1
    }
  }
}

object Vectors {

  /**
    * Creates a dense vector from its values.
    */
  def dense(firstValue: Double, otherValues: Double*): Vector = new DenseVector((firstValue +: otherValues).toArray)

  // A dummy implicit is used to avoid signature collision with the one generated by @varargs.
  /**
    * Creates a dense vector from a double array.
    */
  def dense(values: Array[Double]): Vector = new DenseVector(values)

  /**
    * Creates a sparse vector providing its index array and value array.
    *
    * @param size    vector size.
    * @param indices index array, must be strictly increasing.
    * @param values  value array, must have the same length as indices.
    */
  def sparse(size: Int, indices: Array[Int], values: Array[Double]): Vector = new SparseVector(size, indices, values)

  /**
    * Creates a sparse vector providing its all (index, value) two-tuples.
    *
    * @param size vector size.
    * @param elements all (index, value) two-tuples.
    * @return
    */
  def sparse(size: Int, elements: Seq[(Int, Double)]): Vector = {
    require(size > 0, "The size of the requested sparse vector must be greater than 0.")

    val (indices, values) = elements.sortBy(_._1).unzip
    var prev = -1
    indices.foreach { i =>
      require(prev < i, s"Found duplicate indices: $i.")
      prev = i
    }
    require(prev < size, s"You may not write an element to index $prev because the declared " +
      s"size of your vector is $size")
    new SparseVector(size, indices.toArray, values.toArray)
  }

}